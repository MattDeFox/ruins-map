<script>
(function(){
  const STORAGE_KEY = 'ruinsMapState';
  const MAX_TILES_PER_GUILD = 4;
  let svg = null;
  let tilePaths = [];
  let activeGuild = null;
  let guilds = new Map();
  let assignments = {};
  const tileSelector = 'path[id^="ruin"], path[id^="RUIN"], path[id*="ruin"]';

  const typeColors = {
    '1': 'var(--ruin1-color)',
    '2': 'var(--ruin2-color)',
    '3': 'var(--ruin3-color)',
    '4': 'var(--ruin4-color)',
    '5': 'var(--ruin5-color)',
    'throne': 'var(--throne-color)'
  };

  const mapObj = document.getElementById('map');
  const svgHost = document.getElementById('svgHost');
  const codeInput = document.getElementById('guildCode');
  const colorInput = document.getElementById('guildColor');
  const addBtn = document.getElementById('addGuild');
  const clearGuildsBtn = document.getElementById('clearGuilds');
  const legend = document.getElementById('legend');
  const clearAssignBtn = document.getElementById('clearAssignments');
  const repaintBtn = document.getElementById('repaint');
  const exportBtn = document.getElementById('exportBtn');
  const importBtn = document.getElementById('importBtn');
  const wipeBtn = document.getElementById('wipeStorage');
  const io = document.getElementById('io');

  function normalizeCode(v) {
    return (v || '').toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0, 3);
  }

  function persist() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify({
      guilds: Object.fromEntries(guilds),
      assignments
    }));
  }

  function restore() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      const data = JSON.parse(raw);
      if (data.guilds) guilds = new Map(Object.entries(data.guilds));
      if (data.assignments) assignments = data.assignments;
    } catch (e) {
      console.warn('restore failed', e);
    }
  }

  function getRuinType(groupId) {
    const m = groupId.match(/^ruin(\d+)/i);
    if (m) return m[1];
    if (/throne/i.test(groupId)) return 'throne';
    return null;
  }

  function paintTile(p) {
  const grp = p.closest('g[id^="ruin"]');
  let type = grp ? getRuinType(grp.id) : null;

  // Resolve the actual color from CSS variable
  let baseColor = '#ccc';
  if (type && typeColors[type]) {
    baseColor = getComputedStyle(document.documentElement).getPropertyValue(typeColors[type]).trim();
  }

  const code = assignments[p.id];

  p.style.stroke = 'var(--tile-stroke)';
  p.style.strokeWidth = 2;

  if (code) {
    p.style.fill = guilds.get(code) || '#888';
    p.style.fillOpacity = 0.7;
  } else {
    p.style.fill = baseColor;
    p.style.fillOpacity = 1;
  }
}

  function addLabels() {
    if (!svg) return;
    svg.querySelector('#_labels')?.remove();
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    g.setAttribute('id', '_labels');
    g.setAttribute('pointer-events', 'none');

    const groups = Array.from(svg.querySelectorAll('g[id^="ruin"]'));
    for (const grp of groups) {
      const type = getRuinType(grp.id);
      if (!type) continue;
      const path = grp.querySelector('path[id]') || grp.firstElementChild;
      if (!path) continue;
      const { x, y, width, height } = path.getBBox();
      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('class', 'svg-label');
      text.setAttribute('x', x + width / 2);
      text.setAttribute('y', y + height / 2);
      text.textContent = type === 'throne' ? 'Throne' : type;
      g.appendChild(text);
    }

    svg.appendChild(g);
  }

  function attachInteractivity() {
    if (!svg) {
      alert('No <svg> found inside RuinsMapX.svg');
      return;
    }

    tilePaths = Array.from(svg.querySelectorAll(tileSelector));
    tilePaths.forEach(p => {
      p.style.cursor = 'pointer';
      p.addEventListener('click', e => {
        e.preventDefault();
        const id = p.id || p.getAttribute('id');
        const cur = assignments[id];

        if (e.shiftKey || !activeGuild) {
          delete assignments[id];
        } else {
          const count = Object.values(assignments).filter(v => v === activeGuild).length;
          const isAssigning = cur !== activeGuild;
          if (isAssigning && count >= MAX_TILES_PER_GUILD) {
            alert(`Guild ${activeGuild} has reached the max of ${MAX_TILES_PER_GUILD} tiles.`);
            return;
          }
          assignments[id] = isAssigning ? activeGuild : undefined;
          if (assignments[id] === undefined) delete assignments[id];
        }

        paintTile(p);
        persist();
      });
    });

    repaintAll();
  }

  async function loadSVG() {
    if (mapObj.contentDocument) {
      const doc = mapObj.contentDocument;
      const maybe = doc.querySelector('svg, svg\\:svg') || (/svg$/i.test(doc.documentElement.tagName) ? doc.documentElement : null);
      if (maybe) {
        svg = maybe;
        return true;
      }
    }

    try {
      const url = mapObj.getAttribute('data');
      const resp = await fetch(url, { cache: 'no-cache' });
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const text = await resp.text();
      const parsed = new DOMParser().parseFromString(text, 'image/svg+xml');
      const root = parsed.documentElement;
      if (!root || root.nodeName.toLowerCase() !== 'svg') throw new Error('Parsed document is not <svg>');
      svgHost.innerHTML = '';
      svgHost.style.display = 'block';
      mapObj.style.display = 'none';
      const imported = document.importNode(root, true);
      svgHost.appendChild(imported);
      svg = svgHost.querySelector('svg');
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');
      if (!svg.getAttribute('viewBox')) {
        const w = parseFloat(svg.getAttribute('width')) || 1536;
        const h = parseFloat(svg.getAttribute('height')) || 1536;
        svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
      }
      return true;
    } catch (err) {
      alert(`Failed to load SVG (${err.message}). Check filename and server path.`);
      return false;
    }
  }

  function renderLegend() {
    legend.innerHTML = '';
    for (const [code, color] of guilds) {
      const chip = document.createElement('div');
      chip.className = 'chip' + (activeGuild === code ? ' active' : '');
      chip.setAttribute('data-code', code);
      chip.title = `Set active: ${code}`;
      chip.innerHTML = `<span class="dot" style="background:${color}"></span><span class="code">${code}</span><span class="rm" title="Remove guild">✕</span>`;
      chip.addEventListener('click', e => {
        if (e.target.classList.contains('rm')) {
          removeGuild(code);
          return;
        }
        activeGuild = (activeGuild === code) ? null : code;
        renderLegend();
      });
      legend.appendChild(chip);
    }
  }

  function removeGuild(code) {
    guilds.delete(code);
    Object.keys(assignments).forEach(k => {
      if (assignments[k] === code) delete assignments[k];
    });
    if (activeGuild === code) activeGuild = null;
    renderLegend();
    repaintAll();
    persist();
  }

  restore();
  renderLegend();

  let tried = false;
  mapObj.addEventListener('load', async () => {
    if (tried) return;
    tried = true;
    const ok = await loadSVG();
    if (ok) attachInteractivity();
  }, { once: true });

  setTimeout(async () => {
    if (svg) return;
    const ok = await loadSVG();
    if (ok) attachInteractivity();
  }, 700);

  // UI Events
  addBtn.addEventListener('click', () => {
    const code = normalizeCode(codeInput.value);
    if (!code || code.length < 2) {
      alert('Use a 2–3 character code.');
      return;
    }
    if (guilds.has(code)) {
      alert('That code already exists.');
      return;
    }
    if (guilds.size >= 25) {
      alert('Limit is 25 guilds.');
      return;
    }
    const c = colorInput?.value || '#888';
    guilds.set(code, c);
    activeGuild = code;
    codeInput.value = '';
    renderLegend();
    persist();
  });

  clearGuildsBtn.addEventListener('click', () => {
    if (!confirm('Remove all guilds and their assignments?')) return;
    guilds.clear();
    assignments = {};
    activeGuild = null;
    renderLegend();
    repaintAll();
    persist();
  });

  clearAssignBtn.addEventListener('click', () => {
    if (!confirm('Unassign all tiles?')) return;
    assignments = {};
    repaintAll();
    persist();
  });

  repaintBtn.addEventListener('click', () => repaintAll());

  exportBtn.addEventListener('click', () => {
    io.value = JSON.stringify({ guilds: Object.fromEntries(guilds), assignments }, null, 2);
  });

  importBtn.addEventListener('click', () => {
    let obj;
    try {
      obj = JSON.parse(io.value);
    } catch (e) {
      alert('Invalid JSON');
      return;
    }
    if (!obj || typeof obj !== 'object') {
      alert('Invalid object');
      return;
    }
    if (obj.guilds) guilds = new Map(Object.entries(obj.guilds));
    if (obj.assignments) assignments = obj.assignments;
    activeGuild = null;
    renderLegend();
    repaintAll();
    persist();
  });

  wipeBtn.addEventListener('click', () => {
    if (!confirm('Wipe localStorage for this map?')) return;
    localStorage.removeItem(STORAGE_KEY);
    alert('Storage cleared.');
  });

  codeInput.addEventListener('keydown', e => {
    if (e.key === 'Enter') addBtn.click();
  });

})();
</script>
