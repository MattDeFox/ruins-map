<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ruins Map â€“ Guild Control Prototype</title>
  <style>
    :root {
      --map-bg: #a3aaba;
      --tile-stroke: #2c2f35;
      --label-color: #0b0f18;

      /* Default theme colors */
      --ruin1-color: #dfeafe;
      --ruin2-color: #cddcf9;
      --ruin3-color: #e6efff;
      --ruin4-color: #edf4fe;
      --ruin5-color: #bdd0f8;
      --throne-color: #dfeafe;
    }

    html, body { height: 100%; margin: 0; }

    body {
      display: grid;
      grid-template-columns: 1fr 360px;
      gap: 14px;
      padding: 14px;
      background: radial-gradient(60vmax 60vmax at 10% 0%, #101525 0, #0b0d12 55%);
      color: var(--ink, #e6e9f2);
      font: 14px/1.4 system-ui, sans-serif;
    }

    #mapWrap {
      background: var(--map-bg);
      border: 1px solid #243048;
      border-radius: 14px;
      position: relative;
      display: grid;
      place-items: center;
      padding: 10px;
    }

    #mapBox {
      width: min(90vmin, 800px);
      max-width: 800px;
      min-width: 600px;
      aspect-ratio: 1 / 1;
      position: relative;
    }

    @media (max-width: 720px) {
      body { grid-template-columns: 1fr; }
      #mapBox { width: 92vmin; min-width: 0; }
    }

    object#map {
      width: 100%;
      height: 100%;
      display: block;
      background: var(--map-bg);
      border-radius: 10px;
    }

    #svgHost {
      position: absolute;
      inset: 0;
      display: none;
    }

    #ui {
      background: var(--panel, #121620);
      border: 1px solid #243048;
      border-radius: 14px;
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    h1 {
      font-size: 16px;
      margin: 0 0 8px;
      letter-spacing: .3px;
      color: #d9e2ff;
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    input[type="text"] {
      background: #0e1321;
      color: var(--ink, #e6e9f2);
      border: 1px solid #27324a;
      border-radius: 8px;
      padding: 8px 10px;
      width: 90px;
      text-transform: uppercase;
    }

    input[type="color"] {
      width: 40px;
      height: 36px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      background: #0e1321;
    }

    button {
      background: #182134;
      color: var(--ink, #e6e9f2);
      border: 1px solid #2d3a58;
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer;
    }

    button.primary {
      border-color: #3a56ff55;
      box-shadow: inset 0 0 0 1px #3a56ff33;
    }

    button.danger {
      border-color: #ff6b6b66;
      color: #ffc9c9;
    }

    button:disabled {
      opacity: .45;
      cursor: not-allowed;
    }

    #legend {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .chip {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 8px;
      border: 1px solid #33405f;
      border-radius: 20px;
      background: var(--chip, #1b2232);
      cursor: pointer;
      user-select: none;
    }

    .chip .dot {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #888;
      box-shadow: 0 0 0 2px #0006 inset;
    }

    .chip.active {
      outline: 2px solid var(--accent, #7aa2ff);
    }

    .chip .code {
      font-weight: 700;
      letter-spacing: .5px;
    }

    .chip .rm {
      margin-left: 4px;
      opacity: .7;
      font-size: 12px;
    }

    #io {
      width: 100%;
      min-height: 140px;
      background: #0d1220;
      color: #dbe1f7;
      border: 1px solid #2a3654;
      border-radius: 10px;
      padding: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }

    .hint {
      color: var(--muted, #8a93a6);
      font-size: 12px;
    }

    .sep {
      height: 1px;
      background: #22304a;
      margin: 4px 0;
      opacity: .6;
    }

    .svg-label {
      fill: #0b0f18;
      font-size: 30px;
      font-weight: 900;
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
      user-select: none;
    }
  </style>
</head>

<body>
  <div id="mapWrap">
    <div id="mapBox">
      <object id="map"
              data="RuinsMapX.svg"
              type="image/svg+xml"
              tabindex="-1"
              aria-label="Ruins Map"></object>
      <div id="svgHost"></div>
    </div>
  </div>

  <aside id="ui" aria-label="Controls">
    <div>
      <h1>Guilds</h1>
      <div class="row">
        <input id="guildCode" maxlength="3" placeholder="TAG" aria-label="3-letter guild code" />
        <input type="color" id="guildColor" value="#7aa2ff" title="Pick guild color" />
        <button id="addGuild" class="primary">Add</button>
        <button id="clearGuilds" class="danger" title="Remove all guilds">Clear All</button>
      </div>
      <div id="legend"></div>
      <div class="hint">Tip: click a chip to make it active. Click again to deactivate. Shift+Click a tile to unassign.</div>
    </div>

    <div class="sep"></div>

    <div>
      <h1>Tiles</h1>
      <div class="row">
        <button id="clearAssignments" class="danger">Unassign All Tiles</button>
        <button id="repaint">Repaint</button>
      </div>
      <div class="hint">If no guild is active, clicking a tile unassigns it.</div>
    </div>

    <div class="sep"></div>

    <div>
      <h1>Save / Load</h1>
      <div class="row">
        <button id="exportBtn">Export JSON</button>
        <button id="importBtn" class="primary">Import JSON</button>
        <button id="wipeStorage" class="danger">Wipe Storage</button>
      </div>
      <textarea id="io" spellcheck="false" placeholder="Click Export to see state here, or paste JSON then Import."></textarea>
      <div class="hint">State is also auto-saved to <code>localStorage</code> as <code>ruinsMapState</code>.</div>
    </div>
  </aside>

  <script>
    (function(){
      const STORAGE_KEY = 'ruinsMapState';
      const MAX_TILES_PER_GUILD = 4;
      let svg = null;
      let tilePaths = [];
      let activeGuild = null;
      let guilds = new Map();
      let assignments = {};

      const tileSelector = 'path[id^="ruin"], path[id^="RUIN"], path[id*="ruin"]';
      const typeColors = {
        '1': 'var(--ruin1-color)',
        '2': 'var(--ruin2-color)',
        '3': 'var(--ruin3-color)',
        '4': 'var(--ruin4-color)',
        '5': 'var(--ruin5-color)',
        'throne': 'var(--throne-color)'
      };

      const mapObj = document.getElementById('map');
      const svgHost = document.getElementById('svgHost');
      const codeInput = document.getElementById('guildCode');
      const colorInput = document.getElementById('guildColor');
      const addBtn = document.getElementById('addGuild');
      const clearGuildsBtn = document.getElementById('clearGuilds');
      const legend = document.getElementById('legend');
      const clearAssignBtn = document.getElementById('clearAssignments');
      const repaintBtn = document.getElementById('repaint');
      const exportBtn = document.getElementById('exportBtn');
      const importBtn = document.getElementById('importBtn');
      const wipeBtn = document.getElementById('wipeStorage');
      const io = document.getElementById('io');

      function normalizeCode(v) {
        return (v || '').toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0, 3);
      }

      function persist() {
        localStorage.setItem(STORAGE_KEY, JSON.stringify({
          guilds: Object.fromEntries(guilds),
          assignments
        }));
      }

      function restore() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return;
          const data = JSON.parse(raw);
          if (data.guilds) guilds = new Map(Object.entries(data.guilds));
          if (data.assignments) assignments = data.assignments;
        } catch (e) {
          console.warn('restore failed', e);
        }
      }

      function getRuinType(id) {
        const m = id.match(/ruin(\d+)/i);
        if (m) return m[1];
        if (/throne/i.test(id)) return 'throne';
        return null;
      }

      function paintTile(p) {
  const grp = p.closest('g[id^="ruin"]');
  const type = grp ? getRuinType(grp.id) : null;

  let baseColor = '#ccc';

  if (type && typeColors[type]) {
    const computed = getComputedStyle(document.documentElement)
      .getPropertyValue(typeColors[type])
      .trim();

    // Fallback to hardcoded value if computed is empty
    baseColor = computed || {
      '1': '#dfeafe',
      '2': '#cddcf9',
      '3': '#e6efff',
      '4': '#edf4fe',
      '5': '#bdd0f8',
      'throne': '#dfeafe'
    }[type] || '#ccc';
  }

  const code = assignments[p.id];
  p.style.stroke = 'var(--tile-stroke)';
  p.style.strokeWidth = 1;

  if (code) {
    p.style.fill = guilds.get(code) || '#888';
    p.style.fillOpacity = 0.7;
  } else {
    p.style.fill = baseColor;
    p.style.fillOpacity = 1;
  }
}

      function addLabels() {
        if (!svg) return;
        svg.querySelector('#_labels')?.remove();

        const labelLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        labelLayer.setAttribute('id', '_labels');
        labelLayer.setAttribute('pointer-events', 'none');

        const paths = Array.from(svg.querySelectorAll(tileSelector));

        for (const p of paths) {
          const id = p.id || p.getAttribute('id');
          const type = getRuinType(id);
          if (!type) continue;

          const bbox = p.getBBox();
          const cx = bbox.x + bbox.width / 2;
          const cy = bbox.y + bbox.height / 2;

          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('x', cx);
          text.setAttribute('y', cy);
          text.setAttribute('text-anchor', 'middle');
          text.setAttribute('dominant-baseline', 'middle');
          text.setAttribute('font-family', 'system-ui, sans-serif');
          text.setAttribute('font-weight', '900');
          text.setAttribute('font-size', '28');
          text.setAttribute('fill', '#262f40');
          text.setAttribute('stroke', '#fff');
          text.setAttribute('stroke-width', '1');
          text.classList.add('svg-label');
          text.textContent = (type === 'throne') ? 'â™›' : type;

          labelLayer.appendChild(text);
        }

        svg.appendChild(labelLayer);
      }

      function repaintAll() {
        if (!tilePaths) return;
         tilePaths.forEach(p => paintTile(p));
         addLabels();
        }      

      function attachInteractivity() {
        if (!svg) {
          alert('No <svg> found inside RuinsMapX.svg');
          return;
        }

        tilePaths = Array.from(svg.querySelectorAll(tileSelector));
        tilePaths.forEach(p => {
          p.style.cursor = 'pointer';
          p.addEventListener('click', e => {
            e.preventDefault();
            const id = p.id || p.getAttribute('id');
            const cur = assignments[id];
            const isThrone = /throne/i.test(id);
            const isAssigning = cur !== activeGuild;

            if (e.shiftKey || !activeGuild) {
              delete assignments[id];
            } else {
              // Apply tile restriction unless throne
              if (isAssigning && !isThrone) {
                const count = Object.values(assignments).filter(v => v === activeGuild).length;
                if (count >= MAX_TILES_PER_GUILD) {
                  alert(`Guild ${activeGuild} has reached the max of ${MAX_TILES_PER_GUILD} tiles.`);
                  return;
                }
              }

              assignments[id] = isAssigning ? activeGuild : undefined;
              if (assignments[id] === undefined) delete assignments[id];
            }

            paintTile(p);
            persist();
          });
        });

        repaintAll();
      }

      async function loadSVG() {
        if (mapObj.contentDocument) {
          const doc = mapObj.contentDocument;
          const maybe = doc.querySelector('svg, svg\\:svg') ||
            (/svg$/i.test(doc.documentElement.tagName) ? doc.documentElement : null);
          if (maybe) {
            svg = maybe;
            return true;
          }
        }
        try {
          const url = mapObj.getAttribute('data');
          const resp = await fetch(url, { cache: 'no-cache' });
          if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
          const text = await resp.text();
          const parsed = new DOMParser().parseFromString(text, 'image/svg+xml');
          const root = parsed.documentElement;
          if (!root || root.nodeName.toLowerCase() !== 'svg')
            throw new Error('Parsed document is not <svg>');
          svgHost.innerHTML = '';
          svgHost.style.display = 'block';
          mapObj.style.display = 'none';
          const imported = document.importNode(root, true);
          svgHost.appendChild(imported);
          svg = svgHost.querySelector('svg');
          svg.setAttribute('width', '100%');
          svg.setAttribute('height', '100%');
          if (!svg.getAttribute('viewBox')) {
            const w = parseFloat(svg.getAttribute('width')) || 1536;
            const h = parseFloat(svg.getAttribute('height')) || 1536;
            svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
          }
          return true;
        } catch (err) {
          alert(`Failed to load SVG (${err.message}). Check filename and server path.`);
          return false;
        }
      }

      function renderLegend() {
        legend.innerHTML = '';
        for (const [code, color] of guilds) {
          const chip = document.createElement('div');
          chip.className = 'chip' + (activeGuild === code ? ' active' : '');
          chip.setAttribute('data-code', code);
          chip.title = `Set active: ${code}`;
          chip.innerHTML =
            `<span class="dot" style="background:${color}"></span>` +
            `<span class="code">${code}</span>` +
            `<span class="rm" title="Remove guild">âœ•</span>`;
          chip.addEventListener('click', e => {
            if (e.target.classList.contains('rm')) {
              removeGuild(code);
              return;
            }
            activeGuild = (activeGuild === code) ? null : code;
            renderLegend();
          });
          legend.appendChild(chip);
        }
      }

      function removeGuild(code) {
        guilds.delete(code);
        Object.keys(assignments).forEach(k => {
          if (assignments[k] === code) delete assignments[k];
        });
        if (activeGuild === code) activeGuild = null;
        renderLegend();
        repaintAll();
        persist();
      }

      restore();
      renderLegend();

      let tried = false;
      mapObj.addEventListener('load', async () => {
        if (tried) return;
        tried = true;
        const ok = await loadSVG();
        if (ok) attachInteractivity();
      }, { once: true });

      setTimeout(async () => {
        if (svg) return;
        const ok = await loadSVG();
        if (ok) attachInteractivity();
      }, 700);

           // === UI Handlers ===
      addBtn.addEventListener('click', () => {
        const code = normalizeCode(codeInput.value);
        if (!code || code.length < 2) {
          alert('Use a 2â€“3 character code.');
          return;
        }
        if (guilds.has(code)) {
          alert('That code already exists.');
          return;
        }
        if (guilds.size >= 25) {
          alert('Limit is 25 guilds.');
          return;
        }
        const c = colorInput?.value || '#888';
        guilds.set(code, c);
        activeGuild = code;
        codeInput.value = '';
        renderLegend();
        persist();
      });

      clearGuildsBtn.addEventListener('click', () => {
        if (!confirm('Remove all guilds and their assignments?')) return;
        guilds.clear();
        assignments = {};
        activeGuild = null;
        renderLegend();
        repaintAll();
        persist();
      });

      clearAssignBtn.addEventListener('click', () => {
        if (!confirm('Unassign all tiles?')) return;
        assignments = {};
        repaintAll();
        persist();
      });

      repaintBtn.addEventListener('click', () => repaintAll());

      exportBtn.addEventListener('click', () => {
        io.value = JSON.stringify({ guilds: Object.fromEntries(guilds), assignments }, null, 2);
      });

      importBtn.addEventListener('click', () => {
        let obj;
        try {
          obj = JSON.parse(io.value);
        } catch (e) {
          alert('Invalid JSON');
          return;
        }
        if (!obj || typeof obj !== 'object') {
          alert('Invalid object');
          return;
        }
        if (obj.guilds) guilds = new Map(Object.entries(obj.guilds));
        if (obj.assignments) assignments = obj.assignments;
        activeGuild = null;
        renderLegend();
        repaintAll();
        persist();
      });

      wipeBtn.addEventListener('click', () => {
        if (!confirm('Wipe localStorage for this map?')) return;
        localStorage.removeItem(STORAGE_KEY);
        alert('Storage cleared.');
      });

      codeInput.addEventListener('keydown', e => {
        if (e.key === 'Enter') addBtn.click();
      });
    })();
  </script>
</body>
</html>
